Metadata-Version: 2.1
Name: ml-experiments
Version: 0.0.1
Summary: UNKNOWN
Home-page: https://github.com/lukewood/ml-experiments
Author: Luke Wood
Author-email: lukewoodcs@gmail.com
License: Apache License 2.0
Platform: UNKNOWN
Classifier: Development Status :: 5 - Production/Stable
Classifier: Environment :: Console
Classifier: License :: OSI Approved :: Apache Software License
Classifier: Intended Audience :: Science/Research
Classifier: Programming Language :: Python :: 3
Classifier: Topic :: Scientific/Engineering :: Artificial Intelligence
Description-Content-Type: text/markdown
Provides-Extra: dev

# ML Experiments

*TODO(lukewood):* add PyPi badges, etc.

Based on the `ml-collections` library, `ml-experiments` is an open source tool for
orchestrating machine learning research experiments.

`ml-experiments` allows you to define a configuration object in the style of
`ml-collections` that describes an array of experiments, run all of the experiments,
gather artifacts from the experiments, and aggregate the results into plots, tables,
and figures for use in your research paper.

## Quick-Start

- [Oxford 102 flowers classification example](examples/oxford_102/)
- [Overview](#Overview)
- *(TODO) API documentation*

## Overview

Using `ml-experiments` is easy!  
To get started, you need to be familiar with a few concepts.
This overview covers everything you need to know.

[To quickly jump right into things, check out the Oxford 102 flowers classification example.](examples/oxford_102/)

### Tasks & Tactics

In the mental model of `ml-experiments` there exists *Tasks* and *Tactics*.  A *Task* is
something like: "classify images from MNIST", or "cluster samples into N classes", or
"perform generative learning in X style".  

A *Tactic* refers to the combination of all the details used to produce a
solution to a Task.  For example, one such Tactic for solving MNIST classification might
be to train a ResNet50V2 on data augmented with AugMix.  
Typically, to get a publishable result your paper will require you to have numerous
tactics to benchmark your novel tactic against.

Typically, a research work will have many Tasks: where
the overall goal of the paper is to benchmark a new Tactic's ability at solving a variety
of tasks.

`ml-experiments` is structured around this idea: you will have at least one Task, and
each Task may be solved by numerous tactics.
As such, I recommend breaking your codebase down at the `Task` level, structuring your
paper's artifact with splits made on the `Task` level.  For example, a classification
paper might have the structure:

```
- tasks/
      - mnist/
            - ...
      - imagenet/
            - ...
```

### Code Structure

Keeping these concepts in mind, `ml-experiments` recommends that you structure your code
into three levels:

- `library/` holds anything unique to your paper.  This might include a new
  augmentation, a new `keras.Layer`, a new loss function, or even a new metric.
- `tasks/` holds all of the tasks to benchmark your new technique on.
- `paper/` holds the `Latex` or `Markdown` code required to render your paper
- `paper/artifacts` subdirectory of `paper` that holds all of the artifacts produced by
  the `tasks`.  Typically when running a Task sweep you'll want to provide this directory
  to your scripts.

Your tasks should be structured as follows:

All code for a task should reside in `tasks/{task}/`, i.e. `tasks/oxford_102`.
You should create a `run.py` script.  This script must have a `run()` method that
accepts an `ml_collections.ConfigDict` as its first positional argument.  If you follow
the example in the [Oxford Flowers 102 example](examples/oxford_102/run.py), your
`run.py` file will support both independent run and mass-scale sweeps:

```python
def run(config):
    name = f'{config.optimizer}'
    train_ds, test_ds = tfds.load(
        "oxford102", as_supervised=True, split=["train", "test"]
    )
    model = keras_cv.models.ResNet50V2(
      include_rescaling=True,
      include_top=True,
      classes=102
    )
    model.compile(loss="mse", optimizer=config.optimizer)
    history = model.fit(train_ds, epochs=10)

    return ml_experiments.Result(
        name=name,
        artifacts=[
            ml_experiments.artifacts.KerasHistory(history, name="fit_history"),
        ],
    )

if __name__ == "__main__":
    ml_experiments.run(main)
```

Once you are happy with the results from a single `run.py` run, create a
`launch.py` script.  `launch.py` is responsible for launching the sweep of all
`run.py` runs as specified by the provided `ml_collections.ConfigDict` option:

```python
config = ml_collections.ConfigDict()

config.static_value = 'any-string-or-int-or-float-or-python-object'
config.optimizer = ml_experiments.Sweep(['sgd', 'adam'])

results = ml_experiments.run('run.py', config)

```

Anytime a value of type `ml_experiments.Sweep()` is encountered, the product of all
other defined `ml_experiments.Sweep()` parameters is run with the addition of the new
values in that sweep.  

Be careful with this!  It is easy to create a lot of experiments:

```python
config = ml_collections.ConfigDict()
config.learning_rate = ml_experiments.Sweep([x/100 for x in range(5, 21)])
config.optimizer = ml_experiments.Sweep(['sgd', 'adam'])
config.model = ml_experiments.Sweep(
  ['resnet50', 'resnet50v2', 'densenet101', 'efficientnet']
)
```

This configuration already contains `15 * 2 * 4` or `120` runs!  That is way more than
you'd like.  Try to define a few experiments that are all encompassing.  To accomplish
this, run hyper parameter sweeps separately, and hardcode the values into the final runs
that are used to produce the charts.

After all of your runs are complete, create some charts and plots.  Save them to your
designated `artifacts_dir` so that they are rendered into your paper:

```python
metrics_to_plot = {}

for experiment in results:
    metrics = experiment.get_artifact("fit_history").metrics

    metrics_to_plot[f"{experiment.name} Train"] = metrics["accuracy"]
    metrics_to_plot[f"{experiment.name} Validation"] = metrics["val_accuracy"]

luketils.visualization.line_plot(
    metrics_to_plot,
    path=f"{artifacts_dir}/combined-accuracy.png",
    title="Model Accuracy",
)
```

[This is seen in the oxford_102 example.](examples/oxford_102/)

### Conclusions & Further Reading

Thats all it takes to get running with `ml-experiments`.  Please check out the
[`examples/`](examples/) directory for more reading.  It contains a few more patterns
that might be useful in structuring your experiments.

## Limitiations

:warning: right now `ml-experiments` is under active development :warning:

While the API is relatively straightforward and simple, `ml-experiments`
lacks support for multi-worker experiment runs.  This means that you will need to run
all of your experiments concurrently on a single machine.  If you are running 10-20
`fit()` loops to convergence, this will likely be an extremely expensive process.

Personally, I'd rather just wait for my experiments to run then fiddle with a ton of
infrastructure.  That being said, I mainly run small scale research.

If someone wants to contribute distributed runs, feel free!

## License

[Apache v2 License](LICENSE)

## Contributing

Contributions are more than welcome to `ml-experiments`.  
Please see the GitHub issue tracker, and feel free to pick up any issue annotated
with [Contribution Welcome](TODO).

Additionally, bug reports are not only welcome but encouraged.  
Help me improve `ml-experiments`!  
I made this project because I needed the tool.
I'm sure many others do as well.

## Thanks!

If you find this tool helpful, please toss a GitHub star on the repo and follow me on Twitter.

Thank you to all of our GitHub contributors:

*TODO(lukewood):* include GitHub contributors link


